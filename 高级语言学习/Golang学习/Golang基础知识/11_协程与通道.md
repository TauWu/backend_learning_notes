# 协程与通道

## 并发、并行和协程

### 协程定义

- 并发：一个并发程序能在一个处理器或内核使用多个线程执行
- 并行：一个并行程序在某个时间点能使用多个处理器资源
- `goroutine` 是根据一个或以上的线程的可用性，映射在它们之上；协程调度器在 Go 运行的时候就能完成对协程的调度。
- `goroutine` 和 `coroutine` 的区别：
    - `goroutine` 意味着并行，协程一般来说并不能这样
    - `goroutine` 通过信道来相互通信；`coroutine` 通过让出和恢复操作来通信

## 协程间的信道

### channel 的创建
```go
// var identifier chan datatype
var a chan string
a = make(chan string)

// OR
a := make(chan string)
```

### 通信操作符 `<-`

- 发送
`ch <- int1` 用通道 ch 发送变量 int1

- 接收
`int2 = <- ch` 

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan string)

    go setData(ch)
    go getData(ch)

    time.sleep(1e9)
}

func setData(ch chan string) {

    ch <- "test"
    ch <- "hell"

}

func getData(ch chan string) {
    var input string
    for {
        input = <-ch
        fmt.Printf("%s, ", input)
    }
}

```
由上述代码可以看出，需要通信的两个协程，需要设置同一个 channel 来让两个协程之间进行通信。

### 通道阻塞
对于同一个 channel，接收操作是阻塞的，直到发送者可用，如果通道中没有数据，接受者阻塞。

### 通道工厂模式
不将通道作为参数传递给协程，而用函数来生成一个通道并返回（工厂角色）；函数内部有两个匿名函数被协程调用。


## 使用 select 切换协程
从不同的并发执行的协程中获取值可以通过关键字 select 来实现。
```go
select {
    case u: <- ch1:
        // ...
    case v: <- ch2:
        // ...
default:
    // ...
}
```

## 协程和恢复

```go
func server(workChan <-chan *Work) {
    for work:= range workChan {
        go safeDo(work)
    }
}

func safeDo(work *Work){
    defer func(){
        if err := recover(); err!= nil{
            log.Printf("Work failed with %s in %v", err, work)
        }
    }()
    do(work)
}

```